<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>ICLC 2016 Workshop: Design a Mini-Language</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href="https://fonts.googleapis.com/css?family=Raleway:400,300,600" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="css/normalize.css">
<link rel="stylesheet" href="css/skeleton.css">
<link rel="stylesheet" href="css/codemirror.css">
<link rel="stylesheet" href="css/github.min.css">

<script src="js/jquery.min.js"></script>

<script src="js/marked.js"></script>
<script src="js/highlight.min.js"></script>
<script src="js/hljs/javascript.min.js"></script>

<script src="js/peg.min.js"></script>
<script src="js/pegjs.pegjs.js"></script>

<script src="js/codemirror.min.js"></script>
<script src="js/mode/pegjs.min.js"></script>

<script src="js/big.min.js"></script>
<script src="js/gibberish.min.js"></script>
<script src="js/iclc.js"></script>

<style>
/* see http://getskeleton.com/ */
html { font-size: 50%; } 
table { width:100%; }
</style>
</head>
<body>

<script type="bogus" id="sourcetext">

# Design a Mini Live Coding Language

*International Live Coding Conference 2016, Hamilton, Canada*

> In this workshop participants will design and develop a idiosyncratic (perhaps even esoteric) language for live coding. Participants will use an open-source, browser-based code editor capable of communicating with a variety of audio platforms (such as the native browser audio API, Ableton Live, and Max/MSP). The workshop will give a gentle introduction to the construction of grammars for parsing, using friendly browser-based libraries, with which participants will design their own mini-languages for defining musical patterns. Participants will take turns experimenting with the other languages created in the workshop, obtaining feedback and inspiration from each other, and will leave with the knowledge required to continue development of their language on their own.

Instructors: [Graham Wakefield](http://www.grahamwakefield.net) & [Charlie Roberts](http://www.charlie-roberts.com)

---

**Invent your own language!**

In this workshop participants will create their own, idiosyncratic (perhaps even esoteric) mini-languages for live coding. These languages will be designed and run in a readily-accessible browser-based code editor. The workshop will give a gentle introduction to the construction of languages via parsing expression grammars. No experience in any of these specific technologies is necessary. However, some programming experience will be helpful. An open-source browser-based editing environment and support library will be provided to participants. This environment leverages the codemirror and peg.js projects, and can dynamically evaluate code to communicate via websockets or OSC with a variety of platforms for generating audiovisual content. The workshop concentrates upon the editing, parsing, scheduling and annotation of live code within this environment, but examples will be worked through driving standalone engines including Max/MSP and Ableton Live (we will provide a standalone app for participants who do not have Live and Max), as well as addressing the Web Audio API (available in most modern browsers). Although participants will develop for the target of their choice many language features will be agnostic to the intended target platform. 

Time-permitting, language features explored in the workshop will include:
- Basic concepts of grammars: rules, literals, sequences, alternatives, actions, etc.
- Triggering code fragments
- Sequencing and the creation of patterns
- Pattern manipulation and transformation
- Modulation of properties using nested expressions
- Perhaps even self-modifying code

By the end of the workshop users will have created a small idiosyncratic (and perhaps esoteric) live-coding language capable of targeting a variety of platforms. We will reserve time for participants to experiment with other languages created in the workshop, so that they can obtain feedback and inspiration from each other. Participants will leave with the knowledge required to continue development of their language on their own.

<div id="toc"></div>

## Intro

We're going to design languages for live coding. We don't have much time, so they're going to have to be simple, but that doesn't mean they can't be unusual (for inspiration, look at this list of esoteric languages here: https://esolangs.org/wiki/Language_list). Our languages are going to be input as raw text, and our job is to build the parser that can understand this text. Parsing is the general problem of turning raw text into meaningfully-structured data and/or actions, such as sonic events. As language creators, we need to decide what kinds of text fragments will turn into what kinds of actions. We need to know:

1. what kinds of actions can we make?
	- For this workshop, the kinds of actions we can make are instrument note triggers, instrument parameter changes, and ??
2. what kinds of text fragments can we recognize?
	- We'll look at a variety of examples
3. how to specify the mapping between text and action
	- To do this, we're going to learn how to use **[parsing expression grammars](https://en.wikipedia.org/wiki/Parsing_expression_grammar)**

We're going to do most of this using web-based technologies, supported by JavaScript. For example, grammars will be implemented using the [PEG.js](http://pegjs.org) library, the text editor uses the [CodeMirror](http://codemirror.net/) library, our example sounds are generated from the [Gibberish](http://www.charlie-roberts.com/gibberish/) library, etc. -- but you don't really need to know all of this, as they're already built-in to our workshop pages.

## Designing a language's grammar

### Rules

We write grammars as a set of pattern-based rules. A rule has: 

- a **name**, so that you can refer to it elsewhere, 
- a **pattern**, which defines what kinds of text it can recognize,
- an optional **action**, which defines what is returned when a rule applies.

The simplest grammar has only one rule, and the simplest kind of rule looks like this:

```peg
start = "hello"
```

Here `start` is the rule's name, and `"hello"` is the pattern it recognizes. In this case it will match the input only if the input has exactly the word ```hello``` (and nothing else). 

That is, if you give it the input string ```hello``` it will output ```"hello"```. But if you give it any other input string, like ```bye```, it will result in an error like ```Expected "hello" but "b" found.```.

Parsing grammars are often used to more than just *match* an input; they become really powerful when they do some kind of *translation* of the input. This generally means *modifying what a rule returns*. The concept of *modifying what a rule returns* is achieved through **actions**. Actions redefine what the rule returns when it matches input (rather than just returning the input itself). Actions are wrapped in ```{``` and ```}``` curly parentheses, and should contain a ```return``` statement to specify what is returned. For example, we could add an action to our parser to return our input in a different language:

```peg
start = "hello" { return "bonjour"; }
```

With input ```hello``` this now outputs ```"bonjour"```. When considering a parser as a translator like this (sometimes also known as a "transpiler"), the language recognized and translated from is the *source language*, and the language produced as a result is the *target language*. 

---

These are the basics. The rest is just learning how these can get more expressive. For example, the patterns of a rule can include more than just strings of text; they can have sequences, alternate options, optional items, and most importantly, they can refer to other rules. And as we shall see later, what goes between the ```{``` and ```}``` of an action is actually a fragment of Javascript code. That means we can do all kinds of interesting transformations in our translations.

---

### Pattern concepts


#### This then that (sequence)

There are only a handful of basic concepts used in the design of a rule's pattern. Let's look at the most common ones.

The simplest concept is of the *sequence of items*. And to specify this concept in a pattern, we just put each of the items in the pattern, with spaces between. For example, we could have considered our match of ```hello``` as matching a sequence of characters, and written it as follows. It functions in exactly the same way:

```peg
start = "h" "e" "l" "l" "o"
```

#### This or that (alternates)

Grammars would be pretty uselessly inflexible if they only recognized one thing. To make flexibility we have a few options. For example, to recognize one of two words, we could use the ```/``` alternate symbol:

```peg
start = "hello" / "bye"
```

Problem is, this can only recognize the words we defined in the grammar. What if we wanted to recognize any old word (even nonsense and imaginary ones)? Well, remembering that we can split a word into a sequence of letters, let's simplify the problem to recognizing any letter. We could start with something like this:

```peg
letter = "a" / "b" / "c" / "d" / "e"
```

...and so on. Didn't want to write all 26 letters. 

#### One of these (sets and ranges)

Luckily, there's a simple way to express a *set* of characters. It means, match any one of the items in the set. Sets are delimited by ```[``` and ```]``` square brackets like this:

```peg
letter = [abcdefghijklmnopqrstuvwxyz]
```

It's still a bit of a mouthful, so there's also a simpler way to express a *range* of characters, like this:

```peg
letter = [a-z]
```

A set can contain several ranges and other characters, for example like thisrs, like this:

```peg
letter = [a-z] / [A-Z] / "@"
```

But this can be even more simply written as:

```peg
letter = [a-zA-Z@]
```

#### One or more

Now to make a word, we can use our letter rule, and we want to say that a word has *one or more* letters. The *one or more* concept is expressed by adding a ```+``` symbol to the end of the pattern, like this:

```peg
word = [a-zA-Z@]+
```

There's also a *zero or more* concept, which is expressed by adding ```*``` instead. We'll use that a bit later.

#### Use that rule again

But, since we'd already defined what a letter is, why not re-use it? Our grammars can easily use rules inside other rules, and this can make things easier to read, more flexible, and eventually also more powerful:

```peg
word = letter+
letter = [a-zA-Z@]
```
All this means is that to match the ```word``` rule, we have to match the ```letter``` rule, one or more times. Simple!

So how about a sentence? A sentence has one or more words, so we can use the ```+``` concept again. But words are separated by spaces. We can approach this by adding a second element to our pattern, like this:

```peg
word = letter+ space
letter = [a-zA-Z@]
space = " "
```

This means, to match the rule ```word``` you must find *one or more* ```letters```, followed by a ```space```. 

Finally we can define a sentence as one or more words:

```peg
sentence = word+
```

We have a problem though. Given an input string ```"live coding"```, our grammar can match up to ```"live "``` as a word. But it can't match ```"coding"``` as a word, since it doesn't have a space after it. And since that fails, the whole parse will fail too. 

#### Optional items

To work around this, we can use the concept of an *optional item*, which won't fail the parse if it isn't present. We mark the space as optional by adding a ```?``` to it:

```peg
sentence = word+
word = letter+ space?
letter = [a-zA-Z@]
space = " "
```

Similarly, we could add support for sentences that end in an optional full stop (period) like this:

```peg
sentence = word+ "."?
word = letter+ space?
letter = [a-zA-Z@]
space = " "
```

We might even want to be flexible and allow multiple spaces, in which case we can use the concept of *zero or more times*, which we indicate with ```*```:

```peg
sentence = word+ "."?
word = letter+ space*
letter = [a-zA-Z@]
space = " "
```

To recap, ```?``` means zero or one, ```*``` means zero or more, and ```+``` means one or more.

#### Give me the raw text

Now let's look at the output. Given the input ```live coding.``` this grammar will match, and return the matches as an object looking like this: 

```javascript
[[[["l","i","v","e"],[" "]],[["c","o","d","i","n","g"],[]]],"."]
```

Look at all those square brackets! They indicate lists (also known as arrays), but where did they all come from?

Simply, every time a *one or more* or *zero or more* rule is used, it will return a list of the items found. In our case for example this is happening in the ```letter+``` pattern. Say we don't want this much detail; we don't care about the individual letters, we just want the words as raw text. We can get that *just give it to me raw* concept by prefixing a pattern with a ```$```. (I don't know why a dollar means *just give it to me raw*.) For example:

```peg
sentence = word+ "."?
word = $letter+ space*
letter = [a-zA-Z@]
space = " "
```

Which gives:

```javascript
[[["live",[" "]],["coding",[]]],"."]
```

This is better, but there are still lots of lists. Lists are also produced every time a *sequence* concept is used. When a rule has a sequence of more than one element (like our ```word``` rule), it will also return a list to contain the elements' matches. 


but probably we don't care about the spaces either (since we have the structure of the list). 

#### Give me a specific part

Quite often we don't actually care about a lot of these items and want to throw them away. This implies *modifying what a rule returns* via an action, but to do this we also need to identify the different parts of the rule in our pattern to capture. We do this by giving them names (also known as labels) marked by the ```:``` colon character. For example, we can label the important part of our ```word``` pattern with the name "text" like this:

```peg
word = text:$letter+ space*
```

Once named, you can use this within the action like this:

```peg
sentence = word+ "."?
word = text:$letter+ space* { return text; }
letter = [a-zA-Z@]
space = " "
```

I.e. the rule matches words and spaces, but only returns the word parts. We can ignore the full stop in the same way:

```peg
sentence = words:word+ "."? { return words; }
word = text:$letter+ space* { return text; }
letter = [a-zA-Z@]
space = " "
```

The result looks immeasurably better:

```javascript
["live","coding"]
```

Now you can easily imagine adding another rule for paragraphs as one or more sentences:

```peg
paragraph = sentence+
sentence = words:word+ "."? space* { return words; }
word = text:$letter+ space* { return text; }
letter = [a-zA-Z@]
space = " "
```

With the input "live coding. it is amazing." it returns the following. Notice how the paragraph and sentence structure is now encoded in the list structure:

```javascript
[["live","coding"],["it","is","amazing"]]
```

#### Recap

Concept											| Syntax 
:--- 											| :---
Exactly the text "abc"							| ```"abc"```
A then B (sequence) 							| ```A B```
A or B (ordered choice) 						| ```A / B```
Optional A 										| ```A?```
Zero or more A's (returns an array)				| ```A*```
One or more A's (returns an array)				| ```A+```
Any one of these characters						| ```[abcdefgABCDEFG]```
 (or simply)									| ```[a-gA-G]```
Capture the raw text of the pattern	A			| ```$A```
Capture A as ```a``` and B as ```b``` for the action | ```a:A b:B```

---

One way of thinking about how to design a language is to start from the result, and work back. The results are the kinds of things our engine can actually produce (or more accurately, the subset of these things that we are likely to want to produce). This way of thinking effectively means designing a collection of short-cuts, short-hands, macros, simple fragments that can expand into fully-specified events. 

---


### Our editor

On the input window, pressing `Ctrl-Enter` or `Cmd-Enter` will trigger the currently selected text.

### Simple examples

Counting the number of words in a block of text:

```peg
// pattern: zero or more instances of a word followed by nonword characters
// action: return the number of instances found
wordcount = w:(word nonword)* { return w.length; }

// one or more letters:
word = [a-zA-Z]+

// zero or more characters, like spaces, full-stops, etc.
nonword = [^a-zA-Z]*
```

### Insights

Though a grammar is defined top-down, it's usually easier to build & think about bottom up. 

Sketching out a few examples of simple phrases or statements the grammar should understand (and what it should reject!) can help. 

You can also think about it in a modular way: what types of things can be plugged into others. E.g., for the form "A + B" you might think of being able to plug numbers, words, and parentheses clauses in, e.g. "a + 1", "x + (y + z)", etc. The rules of the grammar identify things that can be plugged in, and what can be plugged into them.

The core pattern concepts are "exactly this text", "a then b", "a or b", "optionally a", "zero or more a's", "one or more a's", "anything in the range of a to b", "anything except a", "anything that is also", etc. The most important 5 concepts, and how to write them, are:

These can of course be combined:

Concept											| Syntax 
:--- 											| :---
Match "ab", "aab", "aaab", etc.					| ```"a"+ "b"```
A list of zero or more A's and B's 				| ```(A / B)*```

There are also some special helpers that can make grammars a lot easier to write:

Concept 										| Syntax 
:--- 											| :---
Any integer 									| ```[0-9]```
Any lowercase letter 							| ```[a-z]```
Any uppercase letter 							| ```[A-Z]```
Any letter or number 							| ```[a-zA-Z0-9]```
Any non-letter 									| ```[^a-zA-Z]```
Any character at all (always matches)			| ```.```

Advanced: There are also a couple of "predicate" concepts, which test one pattern first (but do not advance the input, nor use the result), and then test the next one and use it. 

Concept 										| Syntax 
:--- 											| :---
A that also matches B (and-predicate) 			| ```&B A```
A that also does not match B (not-predicate) 	| ```!B A```
A (only when followed by B)			 			| ```A &(B)```
A (unless followed by B)					 	| ```A !(B)```

We make rules ("nonterminals") for several reasons:
- the same sub-pattern can reappear in many different locations
- to break up complex patterns into more digestible chunks, with helpful names
- to identify points in the grammar at which structure can change

*Choice is ordered*, which is important. If the first of a set of alternatives matches, the others will be ignored. It can be important therefore to list your alternatives with the most specific/complex first, the most general/simple last. As a simple example, ```"a" / "aa"``` will never select the second option, as the first one would have been valid. 

*Actions*: In most languages, correct syntax doesn't guarantee correct semantics. And in fact, quite often a lot of the syntax is irrelevant -- "var x" is the same as "var       x" in JavaScript, for example -- so frequently our first stage in parsing is throwing away what we don't need and cleaning up what we have. We can do quite a lot of this work directly in the grammar by defining actions, which will be performed on the result of the match. Actions are just bodies of JavaScript. To refer to items in the pattern, we prefix them with a name, followed by a colon:

Concept 										| Syntax 
--- 											| ---
Convert integer-string to number 				| ```n:[0-9] { return +n; }```
Get name in lowercase							| ```name:[a-zA-Z]+ { return name.join("").toLowerCase(); }```

**Moreover, colourless green ideas sleep furiously.** We might be able to *validate* the semantics from within the parser, but sometimes we need a secondary (or more) passes over the result.

#### Except, unless

For example, we want to match a variable name, except if it a reserved keyword. For example, 

```peg
varname "variable name" = !keyword word
```


### Common patterns

Just grab everything at the end of the document. (Notice the use of the $ prefix: this ensures we get the raw text back, rather than a huge array.)

```peg
end "end" = $.* 
```

To actually detect the end of the entire input string, we can assert that there is nothing after it:

```peg
end_of_input = !.
```

A variable name whose first character must be a letter, but subsequent characters can have underscores & numbers. 

```peg
id "id" = $([a-zA-Z] [a-zA-Z0-9_])*
```

Replacing newlines, quotes, and other magic characters to make sure you get a valid string back:

```peg
stringsafe "stringsafe"
 = text:string {
 	return text.replace(/\n/g, "\\n")
 			   .replace(/\r/g, "\\r")
 			   .replace(/\t/g, "\\t")
 			   .replace(/\f/g, "\\f")
 			   .replace(/\'/g, "\\'")
 			   .replace(/\"/g, '\\"')
 			   .replace(/\&/g, "\\&");
 }
```

Grabbing the text inside a string

```peg
string "string"	
 = '"' text:$(!'"' .)* '"' { return text; }
```

Many grammars use the _ underscore character to identify areas of whitespace, including spaces, tabs, newlines etc., as it draws more attention to the other, more significant parts of patterns. (except for languages in which white space is really significant...)

```peg
_ "optional whitespace"
= [ \t\r\n]*

__ "mandatory whitespace"
= [ \t\r\n]+
```

An example that shows how to detect nested structures. In this case, it will match "[x]", "[x[y]]", "[[x]y[z]]" etc., returning the result as properly nested arrays. This technique will also work for more complex delimiters, such as "/*" and "*/". 

```peg
// everything is either a bracketed fragment, or not:
Start        = Bracketed / NonBracketed

// a bracketed fragment is wrapped in [ and ]:
// we only need what is inside, and because of * it will be an array
Bracketed    = Open s:Start* Close { return s; }

// a non-bracketed fragment is any character that isn't [ or ]
// we only need the character, which because of . will match anything
// the !Open and !Close ensure that this character isn't [ or ]
NonBracketed = (!Open !Close c:.) { return c; }

// The opening & closing symbols of a bracket:
Open    = "["
Close   = "]"
```

```peg
// here's a simplified version, which grabs the text written inside /* long comments */
MultiLineComment = "/*" s:(!"*/" .)* "*/" { return s.join(""); }
```

#### Numbers

TL;DR: -- captures decimal numbers and converts to Javascript numbers:

```peg
number = ("-"? (("."? [0-9]+) / ([0-9]+ "." [0-9]*))) { return +text(); }
```

Here are a few patterns for whole numbers:

```peg
single_digit = [0-9]
nonzero_digit = [1-9]

nonzero_integer = nonzero_digit single_digit*
positive_integer = single_digit+
integer = "-"? positive_integer
```

Note that `positive_integer` above will match "0" but also "000"; if you don't want that, here's a refined version:

```peg
// won't match 000
positive_integer = "0" / (nonzero_digit single_digit*)
```

Introducing decimal points gets trickier, depending on how flexible you want to be. "1.2", "34.56", ".00001", "1234.", and negative versions of these? Scientific notation such as "1e10", "0.4e-12"? 

```peg
positive_decimal = ("." single_digit+)
	/ (single_digit+ "." single_digit*)	
	
decimal = "-"? positive_decimal

scientific = (decimal / integer) ("e" integer)?
```

If you want to turn these into actual numbers, rather than strings containing numbers:

```peg
number = scientific { return +text(); }
```

A compressed version of all this:

```peg
number = scientific { return +text(); }
scientific = "-"? (decimal / integer) ("e" "-"? integer)?
decimal = ("." integer) / (integer "." [0-9]*)
integer = [0-9]+
```

#### Notes and chords

How about turning typical note names and chords, such as "c4", "Fbb5", etc. into MIDI equivalents?

```peg
theory_note = c:chroma a1:accidental? a2:accidental? o:octave? {
	if (a1 != undefined) c = c + a1;
	if (a2 != undefined) c = c + a2;
	if (o  != undefined) c = c + o;
	return c;
}

chroma = c:[a-gA-G] { 
	// return MIDI note offset from C:
	switch(c.toUpperCase()) {
	case "C": return 0; break;
	case "D": return 2; break;
	case "E": return 4; break;
	case "F": return 5; break;
	case "G": return 7; break;
	case "A": return 9; break;
	case "B": return 11; break;
	}
}

// sharps and flats
accidental = a:[#b] {
	// return MIDI note offset:
	switch(a) {
    case "#": return +1;
    case "b": return -1;
    }
}

octave = "-"? [0-9] { 
	// MIDI note value of C in this octave:
	return 24 + (+text()) * 12; 
}

freq_note = n:number ("hz" / "Hz") {
	// the formula to turn Hz into MIDI note value:
    return 69 + 17.31234050465299 * Math.log(n / 440);
}

note = freq_note / theory_note
```

And now for chords:

```peg
absolute_chord "absolute chord" 
= base:note chord:chord_extended {
	var result = [];
    for (var e of chord) {
    	result.push(base + e);
    }
    return result;
}

chord_extended "extended chord" 
= chord:chord variants:chord_variant* {
	var last = chord[2];
    for (var v of variants) {
    	chord.push(last + v);
    }
    return chord;
}

chord_variant "chord variant" 
    = "7" { return 3; }
	/ "#7" { return 4; }
	/ "b9" { return 6; }
	/ "9" { return 7; }

chord "chord" 
	= "min" { return [0, 3, 7]; }
	/ "maj" { return [0, 4, 7]; }
	/ "dim" { return [0, 3, 6]; }
	/ "sus" { return [0, 5, 7]; } 
	/ "aug" { return [0, 4, 8]; }
```

#### Time in space

Some live coding languages make an effort to use textual space in a temporally-meaningful way. In ixilang patterns, textual space maps directly onto sound. This works well because sound events are always a single character. To create a rest, insert a space character. The number of characters in a pattern is also the temporal length of the pattern. In Tidal, patterns have a loop length determined by context, which could be for example a couple of beats. By default, events within the pattern are distributed evenly in time, making it easy to create different subdivisions of a meter. Events are delimited by spaces (making them like words). In Gibber, a pattern includes two separate lists, one for the event data, the other for the timing of that data. However in some cases events can be single-characters, granting a mapping of space to time as with ixilang. 

How will you determine the timing of events in a pattern, and will it use character- and/or word-based spacing?

#### LISP

The Lisp programming language has one of the simplest grammars. Everything is a term, which could be a single word be a list of terms; lists are bounded by parentheses and their terms are separated by space characters, or can be empty. Four rules are enough to recognize this language and return its structure in nested arrays:

```peg
// an item can be followed by whitespace
// which we ignore by using the action
// the item itself could be a list or a word
term "term" = body:(list / word) _ { return body; } 

// a pattern is enclosed within parentheses
// it could also be empty
list "list" = "(" _ body:term* ")" { return body; }

// a symbol must not contain parentheses nor whitespace
// use the "$" to get the raw text
word "word" = $[^() \t\n\r]+

// white space is zero or more spaces or tabs (or newlines)
_ "whitespace" = [ \t\n\r]*
```

This could also form the basis of a language for structured patterns. For example, the terms within a list could be annotated with timing:

```peg
term "term" = body:(pattern / event) _ { return body; } 

pattern "pattern" = "(" _ body:term* ")" { 
	var len = body.length;
    var result = [];
    for (var i in body) {
    	result.push({
        	dur: 1/len,
            start: i/len,
            data: body[i]
        });
    }
    return result; 
}

event "event" = $[^() \t\n\r]+

_ "whitespace" = [ \t\n\r]*
```

Given the input string ```((bd hc) sn)```, this returns a Tidal-like interpretation:

```js
[
   {
      "dur": 0.5, "start": 0, "data": [
         { "dur": 0.5, "start": 0, "data": "bd" },
         { "dur": 0.5, "start": 0.5, "data": "hc" }
      ]
   },
   { "dur": 0.5, "start": 0.5, "data": "sn" }
]
```

#### XMLish

```js
tag = _ "<" name:tagname _ attrs:tagattr* _ ">" _ body:tagbody _ "</" tagname ">" _ { 
	return { 
		name:  name, 
		attrs: attrs, 
		body:  body 
	}; 
}

tagname = $(![>/ \t\n\r] .)+

tagattr = _ key:attrname _ "=" _ '"' _ value:attrname _ '"' _ {
	return { key: key, value: value };
}
attrname = $(![>=" \t\n\r] .)+

tagbody = (tag / tagtext)*
tagtext = $(![<] .)+

_ "whitespace" = [ \t\n\r]*
```

---

### Common errors

#### "Infinite loop detected"

It's really easy to make a grammar that can never terminate. Here's a failed attempt to match a string of one or more "a" characters:

```peg
// BAD!!!
X = Y+
Y = "a"*  
```

The problem here is that Y can match nothing (the empty string), since it can match zero or more of something, and X can match one or more of these Y's. That is, X can match one or more nothings. If you think about it, there are an infinite number of times you can match nothing. So X will keep on matching nothing until you run out of memory, and the parser will give up in a poof of ennui.

All you need to do is make sure than under any array-like operation (i.e. any use of + or *), there is no expansion that can match an empty string (e.g. through the use of ? and *). 

So the above grammar can be fixed simply by moving the zero-or-more up to the top:

```peg
X = Y*
Y = "a"+ 
```

#### "Left recursion detected"

There's another common way to make a grammar that can't terminate. A really common example of this is handling math expressions. To match statements like "1", "1+2", "1+2+3" etc, it might be tempting to write this:

```peg
// BAD!!!
Expression = Addition / Value
Addition = Expression "+" Expression
Value = [0-9]
```

The problem is that the Addition rule's first item is Expression, whose first item is Addition, and so on forever -- the parser will keep following this trail of links until it runs out of memory, and never finish its job. 

An even simpler example:

```peg
StringOfAs = StringOfAs "a" / "a"
```

If you get the "Left recursion detected" error, look through each of your rules for their first (left-most) items, and make sure they can't resolve back to themselves. The math grammar above can be fixed by removing this feedback loop by changing the first item in the Addition rule as follows:

```peg
Expression = Addition / Value
Addition = Value ("+" Expression)*
Value = [0-9]
```

However note that the structure it returns will look different. We can use actions to reshuffle the parse tree into the format that we actually want.

#### Getting better errors

If you annotate a rule by putting a string after the rule name, then this string will be used in error reporting. 

```peg
myrule "myrule" = A B
```

This also lets the PEG.js parser know this is a likely location for errors (and it will suppress errors from any nested rules). Usually it's best to put these annotations on the lowest-level rules, so that errors become more localized. Definitely don't put them on your highest-level rules!

--- 

### Target language

The target language of a parser is the language that the parser will generate after running. Often this is a lower-level language, that is, more machine-friendly than human-friendly. 

For the purposes of this workshop we have designed a target language that captures some essential concepts for a musical live coding context, such as playing notes and looping patterns, with some methods to vary patterns as they play. It is intentionally limited to make it fairly easy to learn, yet also intentionally designed to make it possible to express a wide variety of ideas. It is *not* designed to be succinct -- that's the job of the user-facing language you create!

Our target language is a bit like the instruction sequences real compilers use, in that it is a list of commands. However ours can also have nested structures as lists of lists. A simple example is a pattern that plays a note every beat:

```["@loop", ["@note", [1, "@wait"]]]```

This is the same, but randomly varies the time between each beat:

```["@loop", ["@note", [["@pick", [1, 1/2, 2]], "@wait"]]]```

Here's a chord:

```[[440, "@set-freq"], "@note", [550, "@set-freq"], "@note", [660, "@set-freq"], "@note"]```

Here's an arpeggio:

```[12, "@repeat", [[["@alt", [440, 550, 660]], "@set-freq"], "@note", [1, "@wait"]]]```

Here are all the important concepts supported and how to format them in the target code:

Concept 						| Format 
:--- 							| :---
Do nothing						| ```null```
A pattern to do three things	| ```[first, second, third]```
Set note frequency				| ```freq-in-hz, "@set-freq"```
Set note amplitude				| ```amp-from-zero-to-one, "@set-amp"```
Set note duration				| ```duration-in-beats, "@set-dur"```
Play a note						| ```"@note"```
Loop forever					| ```"@loop", pattern-to-loop```
Repeat n times					| ```n, "@repeat", pattern-to-loop```
Wait for n beats (n can be a fraction) | ```n, "@wait"```
Pick random item to execute		| ```"@pick", pattern-of-items-to-pick-from```
Cycle through items to execute	| ```"@alt", pattern-of-items-to-alternate```
Conditional execution 			| ```condition, "@cond", executed-if-true, executed-if-false```
Probabilistic execution			| ```probability, "@chance", executed-if-true, executed-if-false```
Print to console				| ```message, "@print"```
The current note frequency		| ```"@freq"```
The current note amplitude		| ```"@amp"```
The current note duration		| ```"@dur"```
Execute dynamic code			| ```instruction-name-without-the-@, "@execute"```
Send message over websocket		| ```message, "@ws"```
Put a copy on the stack			| ```item, "@dup"``` (stack becomes: item, item)

Concept 						| Format 
:--- 							| :---
a + b							| ```a, b, "@add"``` or ```a, b, "@+"```
a - b							| ```a, b, "@sub"``` or ```a, b, "@-"```
a * b							| ```a, b, "@mul"``` or ```a, b, "@*"```
a / b							| ```a, b, "@div"``` or ```a, b, "@/"```
a % b	 (Euclidean)			| ```a, b, "@wrap"``` or ```a, b, "@%"```
a % b	 (Floored)				| ```a, b, "@mod"```
-a								| ```a, "@neg"```

Note: division, modulo or wrap by zero will return zero.

---

### Nerdy corner

Why Parsing Expression Grammar (PEG) rather than Context-Free Grammar (CFG)? Because the choice operator always selects the first match (in CFG this is ambiguous) -- with PEGs there is only one valid parse tree. Compared to Regular Expressions, PEGs have the ability to define recursive structures (and they're also a bit easier to read!)

This workshop is an example of [Language-oriented programming](https://en.wikipedia.org/wiki/Language-oriented_programming) (LOP); a style of computer programming in which, rather than solving problems in general-purpose programming languages, the programmer creates one or more domain-specific languages for the problem first, and solves the problem in those languages. 

---

## What can we do:

- make patterns
- manipulate patterns
- modulate

</script>

<div class="container">
	<div class="row" style="margin-top: 25%">
		<div class="full column" id="main_body">
		
		</div>
	</div>
	<div class="row">
		<div class="one-half column">
			<h4>Grammar:</h4>
			<textarea id="peged"> 
sentence 
= _ words:word+ _ { 
	return words; 
}

word 
= text:(list / number / $letter+) _ { 
	return text; 
}

list
= "(" _ body:sentence _ ")" {
	return body;
}

_ 
= [ \n\t]* // any spaces, tabs or newlines

letter 
= [a-zA-Z@+*/%?-] // any letter, or hyphen, or @

number 
= text:$("-"? (([0-9]+ ("." [0-9]*)?) / ("." [0-9]+))) { 
	return +text;  // converts text to a Javascript number
}
			</textarea>
			<div id="peg_msg"></div>
		</div>
		<div class="one-half column">
			<h4>Input:</h4>

<textarea id="ed">
@loop (
	(@alt (16 6 15 5 10 4 12) 44 @mul) @set-freq 
    1 @pick (2 3 5 6 5 6 5) @div @set-amp
	@note
	@alt (1 5 1 9) 32 @div @wait 
)
</textarea>

			<div id="ed_msg"></div>
			<hr/>
			<button class="button-primary" id="ed_start">Start</button>
			<button class="button-primary" id="ed_stop">Stop</button>
			<h4>Output:</h4>
			<div id="output"></div>
			<hr/>
    	</div>
	</div>
</div>



<script>

var body = document.getElementById('sourcetext').innerText;
document.getElementById('main_body').innerHTML = marked(body);
document.getElementById('toc').innerHTML = marked(toc.join("\n"));

////////////////////////////////////////////////////////////////////////////////

var peged = CodeMirror.fromTextArea(document.getElementById("peged"), {mode: "pegjs"});
var peg_msg_div = document.getElementById("peg_msg");

var ed;

var ed_trigger = function(ed) {
	// if selection is empty, select entire line or containing block?
	
	if (parser === undefined) make_parser(); 
	
	console.log("trigger", ed.getSelection());
    execute(ed.getSelection());
}

// see http://codemirror.net/3/doc/manual.html#keymaps
var ed_options = {
  extraKeys: {
    "Ctrl-Enter": ed_trigger,
    "Cmd-Enter": ed_trigger,
  }
};

ed = CodeMirror.fromTextArea(document.getElementById("ed"), ed_options);
var ed_msg_div = document.getElementById("ed_msg");
var out_div = document.getElementById("output");

var start_button = document.getElementById("ed_start");
var stop_button = document.getElementById("ed_stop");

start_button.onclick = function() { parse(); }
stop_button.onclick = function() { seq_clear(); }

// events: http://codemirror.net/3/doc/manual.html#events
// e.g. use the "change" event to respond to code without needing to trigger it. e.g. in-place formatting changes, but maybe also super-live-immediate mode! Other cursor/selection/gutter events. 
// "renderLine" event to style-by-parser?
peged.on("change", function(ed, change) {
  parser = undefined;
  parse();
});

ed.on("change", function(ed, change) {
  parse();
});

// PEG:
// http://pegjs.org/documentation

var parser;

function make_parser() {
  peg_msg_div.innerText = "";
  try {
    // update our parser:
    parser = PEG.buildParser(peged.getValue());
  } catch(ex) {
    //console.log(ex.message);
    peg_msg_div.innerText = ex.message;
  }
}

var tracer = {
  trace: function(o) {
    console.log("trace", o);
  }
};

function execute(text) {
	var res = parser.parse(text, { trace: tracer });
    seq_define("default", res); 
    out_div.innerText = JSON.stringify(res);
}	

function parse() {
  ed_msg_div.innerText = "";
  out_div.innerText = "";
  try {
    if (parser === undefined) make_parser(); 
    execute(ed.getValue());
  
  } catch(ex) {
    //console.log(ex.message);
    ed_msg_div.innerText = ex.message;
  }
}

parse();

</script>

</body>
</html>